#	$OpenBSD: pf.conf,v 1.54 2014/08/23 05:49:42 deraadt Exp $
#
# See pf.conf(5) and /etc/examples/pf.conf

# read the log file: tcpdump -n -e -ttt -r /var/log/pflog
# real-time logging: tcpdump -neq -ttt -i pflog0
#                    tcpdump -nettti pflog0 action drop
#		     tcpdump -vvopn -i enc0
# show queue: pfctl -vvsq
# show stats: pfctl -s info
# table stats: pfctl -v -t martians -T show
# show rule nr. 4: pfctl -v -s rules -R 4
# show rules, prepend rule numbers: pfctl -vvsr

# Port Knocking
#portknock1=53
#portknock2=80
#portknock3=443

# https://www.iana.org/assignments/iana-ipv4-special-registry/
# https://www.iana.org/assignments/iana-ipv6-special-registry/
table <martians> const persist counters { \
 0.0.0.0/8 10.0.0.0/8 100.64.0.0/10 127.0.0.0/8 169.254.0.0/16 \
 172.16.0.0/12 192.0.0.0/24 192.0.2.0/24 192.168.0.0/16 198.18.0.0/15 \
 198.51.100.0/24 203.0.113.0/24 240.0.0.0/4 255.255.255.255/32 \
 ::1/128 ::/128 ::/96 ::ffff:0:0/96 100::/64 2001::/32 2001:2::/48 \
 2001:db8::/32 fc00::/7 fe80::/10 }

# full access (for test)
table <knownhosts> persist counters {}

# Enable with: touch /etc/authpf/authpf.conf
table <authpf_users> persist counters

# block bad hosts for 10-11 minutes (controlled by crontab)
table <temporaryban> persist counters
table <permanentban> persist counters file "/etc/pf.permanentban"

# Update the adhosts IP list every month (controlled by crontab)
table <adhosts> persist counters file "/etc/pf.adhosts"

# Update the malware IP list every month (controlled by crontab)
table <malware> persist counters file "/etc/pf.malware"

# Clear (IPs older than 60 sec) portknock1 and portknock2 every 5 minutes
# Clear portknock3 every hour (controlled by crontab)
table <portknock1> persist
table <portknock2> persist
table <portknock3> persist

# Options
set optimization normal
set block-policy drop
set loginterface em0
set skip on { lo0 }

# Sanitizing packet content
# http://man.openbsd.org/pf.conf#Scrub
# no-df + random-id = unique IP identifiers
# max-mss must match net.inet.tcp.mssdflt in /etc/sysctl.conf
match in all scrub (no-df random-id max-mss 1440)

# Queues
# http://man.openbsd.org/pf.conf#QUEUEING
# queue assignment before nat-to http://marc.info/?l=openbsd-misc&m=149163915901383&w=2
queue rootq on em0 bandwidth 20M max 20M
queue web parent rootq bandwidth 10M burst 18M for 100ms
queue mail parent rootq bandwidth 2M
queue ssh parent rootq bandwidth 4M
queue  ssh_interactive parent ssh bandwidth 1M min 0.5M
queue  ssh_bulk parent ssh bandwidth 3M
queue domain parent rootq bandwidth 500K
queue icmp parent rootq bandwidth 500K
queue std parent rootq bandwidth 5M default # +3

match out log on egress inet proto { tcp udp } \
 to port { http https } \
 set queue web \
 tagged LAN_INET
match out log on egress inet6 proto { tcp udp } \
 to port { http https } \
 set queue web \
 tagged LAN6_INET6

match out log on egress inet proto tcp \
 to port { pop3 pop3s imap imaps smtps submission } \
 set queue mail \
 tagged LAN_INET
match out log on egress inet6 proto tcp \
 to port { pop3 pop3s imap imaps smtps submission } \
 set queue mail \
 tagged LAN6_INET6

match out log on egress inet proto tcp \
 to port ssh \
 set queue (ssh_bulk, ssh_interactive) \
 tagged LAN_INET
match out log on egress inet6 proto tcp \
 to port ssh \
 set queue (ssh_bulk, ssh_interactive) \
 tagged LAN6_INET6

#match out log inet proto { tcp udp }
# to port domain
# tagged SELF_INET
# set queue domain

match out log on egress inet proto icmp \
 set queue icmp
match out log on egress inet6 proto icmp6 \
 set queue icmp

# NAT
match out log on egress inet tag LAN_INET_NAT tagged LAN_INET \
 nat-to (egress:0) port 1024:65535

# Classification -- classify packets based on the defined firewall policy.

# Block spoofed traffic
# http://man.openbsd.org/pf.conf#Blocking_Spoofed_Traffic
antispoof log quick for { (egress) lo0 (tun) (vether) (enc) }
antispoof log for { (lan) (wlan) } # why not quick? We allow them on enc

# Block incoming bad packets
block in log quick on egress inet  proto icmp  all icmp-type  redir
block in log quick on egress inet6 proto icmp6 all icmp6-type redir

# Block incoming traffic from the undesirable
block in log quick on egress \
 from { <martians> no-route urpf-failed <temporaryban> <permanentban> <malware> }

# Block outgoing traffic to the undesirable, and tell us it's blocked
block return out log quick on egress \
 to { <martians> no-route <adhosts> <malware> } set queue std

# Block outgoing traffic that hasn't been translated
block out log quick on egress inet from ! (egress:0)

# Confound network scanners
block in log quick proto tcp all flags SF/SFRA
##block in log quick proto tcp all flags SFUP/SFRAU
block in log quick proto tcp all flags FPU/SFRAUP
block in log quick proto tcp all flags /SFRA
block in log quick proto tcp all flags F/SFRA
block in log quick proto tcp all flags U/SFRAU
##block in log quick proto tcp all flags P
block in log quick proto tcp all flags FUP/FUP

# Block all, to explicit pass below
block log all

# LAN_INET_NAT to WAN
pass out log inet tagged LAN_INET_NAT

# LAN6_INET6 to WAN
pass out log on egress inet6 tagged LAN6_INET6

# SELF

# HE.net (6in4)
pass in  log on egress proto ipv6 \
 from 216.66.38.58 to (egress) \
 keep state (if-bound)
pass out log on egress proto ipv6 \
 from (egress) to 216.66.38.58 \
 keep state (if-bound)

# unbound to SELF[6]_INET[6]
pass out log (user) on egress inet  proto { tcp udp } \
 from (egress) to port domain \
 user { _unbound root } set queue domain \
 tag SELF_INET !tagged LAN_INET_NAT
pass out log (user) on egress inet6 proto { tcp udp } \
 from (egress) to port domain \
 user _unbound set queue domain \
 tag SELF6_INET6

# ntpd to SELF[6]_INET[6]
pass out log (user) on egress inet proto { tcp udp } \
 from (egress) to port ntp \
 user { _ntp root } set queue domain \
 tag SELF_INET !tagged LAN_INET_NAT
pass out log (user) on egress inet6 proto udp \
 from (egress) to port ntp \
 user { _ntp root } set queue domain \
 tag SELF6_INET6

# whois to SELF[6]_INET[6]
pass out log (user) on egress inet proto tcp \
 from (egress:0) to port whois \
 user { root horia } \
 tag SELF_INET !tagged LAN_INET_NAT
pass out log (user) on egress inet6 proto tcp \
 from (egress) to port whois \
 user { root horia } \
 tag SELF6_INET6

# ssh to SELF[6]_INET[6]
pass out log (user) on egress inet proto tcp \
 from (egress:0) to port ssh \
 user { root horia } \
 tag SELF_INET !tagged LAN_INET_NAT
pass out log (user) on egress inet6 proto tcp \
 from (egress) to port ssh \
 user { root horia } \
 tag SELF6_INET6

# www to SELF[6]_INET[6]
pass out log (user) on egress inet  proto { tcp udp } \
 from (egress) to port { http https } \
 user { _ntp _pfetch _pkgfetch _syspatch root horia } set queue web \
 tag SELF_INET !tagged LAN_INET_NAT
pass out log (user) on egress inet6 proto { tcp udp } \
 from (egress) to port { http https } \
 user { _ntp _pfetch _pkgfetch _syspatch root horia } set queue web \
 tag SELF6_INET6

# dhclient to SELF_INET
pass out log on egress inet proto udp \
 from (egress:0) port bootpc to port bootps \
 set queue domain \
 tag SELF_INET !tagged LAN_INET_NAT

# DHCPv6 client: receive responses to IA_PD requests
#pass out log on egress inet6 proto udp \
# from (egress:0) port dhcpv6-client to ff02::1:2 port dhcpv6-server \
# set queue domain \
# tag SELF6_INET6
#pass in  log on egress inet6 proto udp \
# to (egress:0) port dhcpv6-client \
# tag INET6_SELF6

# DHCPv6 Server for DNS requests
#pass in log on { lan wlan } inet6 proto udp \
# from fe80::/10 port dhcpv6-client to ff02::1:2 port dhcpv6-server \
# tag LAN6_SELF6
#pass out log on { lan wlan } inet6 proto udp \
# from { (lan) (wlan) } to fe80::/10 port dhcpv6-client \
# tag SELF6_LAN6

# LAN ( lan wlan vether enc tun )

# highest prio first, only when physical interface bandwidth is saturated
# https://marc.info/?l=openbsd-misc&m=145261341431381&w=2

# Anchor rules for various authenticated peers
# all child anchors (/*) within authpf anchor (loaded from
# /etc/authpf/users/$USER/authpf.rules) will be evaluated
anchor "authpf/*" from <authpf_users>
match inet  tag LAN_INET   tagged AUTHPF_INET
match inet6 tag LAN6_INET6 tagged AUTHPF_INET

# Incoming traffic from trusted peers to LAN[6]_INET[6]
pass in log on { lan wlan vether } inet \
 from <knownhosts> to !(self:network) \
 tag LAN_INET
pass in log on { enc tun } inet \
 from <knownhosts> to !(self:network) \
 keep state (if-bound) \
 tag LAN_INET

pass in log on { lan wlan vether } inet6 \
 from <knownhosts> to !(self:network) \
 tag LAN6_INET6
pass in log on { enc tun } inet6 \
 from <knownhosts> to !(self:network) \
 keep state (if-bound) \
 tag LAN6_INET6

# Incoming traffic from trusted peers to LAN[6]
pass in log on { lan wlan vether } inet \
 from { <knownhosts> <authpf_users> } \
 tag LAN !tagged LAN_INET
pass in log on { enc tun } inet \
 from { <knownhosts> <authpf_users> } \
 keep state (if-bound) \
 tag LAN !tagged LAN_INET

pass in log on { lan wlan vether } inet6 \
 from { <knownhosts> <authpf_users> } \
 tag LAN6 !tagged LAN6_INET6
pass in log on { enc tun } inet6 \
 from { <knownhosts> <authpf_users> } \
 keep state (if-bound) \
 tag LAN6 !tagged LAN6_INET6

# Open LAN for trusted peers
pass out log on { lan wlan vether } inet \
 tagged LAN \
 set prio (5, 6) # default prio 3
pass out log on { enc tun } inet \
 keep state (if-bound) \
 tagged LAN \
 set prio (5, 6) # default prio 3

pass out log on { lan wlan vether } inet6 \
 tagged LAN6 \
 set prio (5, 6) # default prio 3
pass out log on { enc tun } inet6 \
 keep state (if-bound) \
 tagged LAN6 \
 set prio (5, 6) # default prio 3

# Add self traffic to LAN
pass out log on { lan wlan vether } inet \
 from (self) to (self:network) \
 set prio (5, 6) # default prio 3
#tag LAN interferes with VPN after a while
pass out log on { enc tun } inet \
 from (self) to (self:network) \
 keep state (if-bound) \
 set prio (5, 6) # default prio 3

# and guests

# www to LAN[6]_INET[6]
pass in log on { lan wlan } inet proto { tcp udp } \
 to !(self:network) port { http https } \
 tag LAN_INET
pass in log on { lan wlan } inet6 proto { tcp udp } \
 from { (lan:network) (wlan:network) } to !(self:network) port { http https } \
 tag LAN6_INET6

pass in log on { enc tun } inet proto { tcp udp } \
 to !(self:network) port { http https } \
 keep state (if-bound) \
 tag LAN_INET tagged VPN
pass in log on enc inet6 proto { tcp udp } \
 to !(self:network) port { http https } \
 keep state (if-bound) \
 tag LAN6_INET6 tagged VPN

# ssh to LAN[6]_SELF[6]
pass in log on { lan wlan } inet proto tcp \
 to (vether0:0) port ssh \
 tag LAN_SELF
pass in log on { lan wlan } inet6 proto tcp \
 to (vether0) port ssh \
 tag LAN6_SELF6

# ssh (VPN) to LAN[6]_SELF[6]
pass in log on { enc tun } inet proto tcp \
 to (vether0:0) port ssh \
 keep state (if-bound) \
 tagged VPN
pass in log on enc inet6 proto tcp \
 to (vether0) port ssh \
 keep state (if-bound) \
 tagged VPN

# Secure forward ftp proxy

# http://man.openbsd.org/ftp-proxy
anchor "ftp-proxy/*"

# ftp for trusted peers
pass in log on { lan wlan } inet proto tcp \
 to port ftp flags S/SAFR modulate state \
 divert-to vether0 port 8021 \
 tagged LAN_INET
pass in log on { enc tun } inet proto tcp \
 to port ftp flags S/SAFR modulate state (if-bound) \
 divert-to vether0 port 8021 \
 tagged LAN_INET

pass in log on { lan wlan enc tun } inet6 proto tcp \
 to port ftp flags S/SAFR modulate state \
 divert-to fd80:1fe9:fcee:1337::ace:face port 8021 \
 tagged LAN6_INET6
pass in log on { enc tun } inet6 proto tcp \
 to port ftp flags S/SAFR modulate state (if-bound) \
 divert-to fd80:1fe9:fcee:1337::ace:face port 8021 \
 tagged LAN6_INET6

# ftp-proxy
pass out log on egress inet proto tcp \
 from (egress:0) to port ftp \
 user _ftp_proxy
pass log tagged FTP_PROXY

pass out log on egress inet6 proto tcp \
 from (egress) to port ftp \
 user _ftp_proxy
pass log tagged FTP_PROXY6

# VPN (IKEv1 and IKEv2)

# Allow ESP encapsulated IPsec traffic

pass in  log on { lan wlan } proto esp \
 to   { (lan) (wlan) }
pass out log on { lan wlan } proto esp \
 from { (lan) (wlan) }

pass in  log on egress proto esp \
 to   (egress)
pass out log on egress proto esp \
 from (egress)

# Only isakmp (500) for IPsec config before l2tp (1701)
# Enable NAT transversal (4500) 

pass in  log on { lan wlan } proto udp \
 to   { (lan) (wlan) } port {isakmp, ipsec-nat-t}
pass out log on { lan wlan } proto udp \
 from { (lan) (wlan) } port {isakmp, ipsec-nat-t}

pass in  log on egress proto udp \
 to   (egress) port {isakmp, ipsec-nat-t}
pass out log on egress proto udp \
 from (egress) port {isakmp, ipsec-nat-t}

# We let isakmpd and iked handle VPN tag

# IP-in-IP traffic flowing between gateways on the enc(4) interface
pass in  log on enc proto ipencap \
 to   { (egress) (lan) (wlan) } keep state (if-bound)
pass out log on enc proto ipencap \
 from { (egress) (lan) (wlan) } keep state (if-bound)

# Filter unencrypted VPN traffic on the enc(4) interface
pass in  log on enc proto udp \
 to   { (egress) (lan) (wlan) } port l2tp keep state (if-bound)
pass out log on enc proto udp \
 from { (egress) (lan) (wlan) } port l2tp keep state (if-bound)

# https://developer.android.com/reference/java/net/InetAddress.html#isReachable(int)
pass in log on { enc tun } proto tcp  \
 to { (egress) (lan) (wlan) (vether) (tun) (enc) } port echo \
 keep state (if-bound) \
 tagged VPN

# https://datatracker.ietf.org/doc/draft-ietf-opsec-icmp-filtering/history/
# https://tools.ietf.org/html/draft-ietf-opsec-icmp-filtering-04
pass     log inet proto icmp             icmp-type  3 code  0 keep state (max 32)
pass     log inet proto icmp             icmp-type  3 code  1 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type  3 code  2 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  3 code  2 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type  3 code  3 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  3 code  3 keep state (max 32)
pass     log inet proto icmp             icmp-type  3 code  4 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type  3 code  5 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  3 code  5 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  3 code  7 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type  3 code 11 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  3 code 11 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type  3 code 12 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  3 code 12 keep state (max 32)
pass     log inet proto icmp             icmp-type  3 code 13 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type  3 code 14 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  3 code 14 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type  3 code 15 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  3 code 15 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type  5 code  0 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  5 code  0 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type  5 code  1 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  5 code  1 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type  5 code  2 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  5 code  2 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type  5 code  3 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  5 code  3 keep state (max 32)
pass     log inet proto icmp             icmp-type 11 code  0 keep state (max 32)
pass     log inet proto icmp             icmp-type 11 code  1 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type 12 code  0 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type 12 code  0 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type 12 code  1 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type 12 code  1 keep state (max 32)
pass     log inet proto icmp             icmp-type  8 code  0 keep state (max 32)
pass     log inet proto icmp             icmp-type  0 code  0 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type 10 code  0 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type 10 code  0 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type  9 code  0 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type  9 code  0 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type 13 code  0 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type 13 code  0 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type 14 code  0 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type 14 code  0 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type 17 code  0 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type 17 code  0 keep state (max 32)
pass in  log inet proto icmp to   (self) icmp-type 18 code  0 keep state (max 32)
pass out log inet proto icmp from (self) icmp-type 18 code  0 keep state (max 32)

# RFC 4890: Recommendations for Filtering ICMPv6 Messages in Firewalls

pass     log inet6 proto icmp6             icmp6-type   1 code  0 keep state (max 32)
pass     log inet6 proto icmp6             icmp6-type   1 code  1 keep state (max 32)
pass in  log inet6 proto icmp6 to   (self) icmp6-type   1 code  2 keep state (max 32)
pass out log inet6 proto icmp6 from (self) icmp6-type   1 code  2 keep state (max 32)
pass     log inet6 proto icmp6             icmp6-type   1 code  3 keep state (max 32)
pass     log inet6 proto icmp6             icmp6-type   1 code  4 keep state (max 32)
pass in  log inet6 proto icmp6 to   (self) icmp6-type   1 code  5 keep state (max 32)
pass out log inet6 proto icmp6 from (self) icmp6-type   1 code  5 keep state (max 32)
pass     log inet6 proto icmp6             icmp6-type   1 code  6 keep state (max 32)
pass     log inet6 proto icmp6             icmp6-type   2 code  0 keep state (max 32)
pass     log inet6 proto icmp6             icmp6-type   3 code  0 keep state (max 32)
pass     log inet6 proto icmp6             icmp6-type   3 code  1 keep state (max 32)
pass in  log inet6 proto icmp6 to   (self) icmp6-type   4 code  0 keep state (max 32)
pass out log inet6 proto icmp6 from (self) icmp6-type   4 code  0 keep state (max 32)
pass in  log inet6 proto icmp6 to   (self) icmp6-type   4 code  1 keep state (max 32)
pass out log inet6 proto icmp6 from (self) icmp6-type   4 code  1 keep state (max 32)
pass     log inet6 proto icmp6             icmp6-type   4 code  2 keep state (max 32)
pass     log inet6 proto icmp6             icmp6-type 128 code  0 keep state (max 32)
pass     log inet6 proto icmp6             icmp6-type 129 code  0 keep state (max 32)

# Mobile IPv6 messages that are needed to assist mobility
pass log inet6 proto icmp6 icmp6-type { 144 145 146 147 }

# RFC 4890, section 4.4
# ff02::1: ff00:2:
pass log inet6 proto icmp6 \
 to { (self) ff02::/16 } \
 icmp6-type { 130 131 132 133 134 135 136 137 141 142 143 148 149 151 152 153 }

# Allow traceroute
#pass in log on egress inet proto udp to (egress) port { 33435:33525 }

# Services on [self: keep state] [other: synproxy state]
# max:               max concurrent connections
# source-track rule: max connections limit by max-src-nodes and max-src-states
#                    (rule per ip, not global)
# max-src-nodes:     max simultaneous sources
# max-src-states:    max simultaneous connection from the same source
# max-src-conn:      max simultaneous established connections from same source
# max-src-conn-rate: max rate of new 3way connections over a time interval (sec)

anchor "relayd/*"

# DNS Layer 3 redirection
pass in log on { lan wlan } inet proto { tcp udp } \
 to port domain \
 tagged RELAYD_DNS
pass in log on { enc tun } inet proto { tcp udp } \
 to port domain keep state (if-bound) \
 tagged RELAYD_DNS

pass in log on { lan wlan } inet6 proto { tcp udp } \
 to port domain \
 tagged RELAYD6_DNS
pass in log on { enc tun } inet6 proto { tcp udp } \
 to port domain keep state (if-bound) \
 tagged RELAYD6_DNS

# NTP Layer 3 redirection
pass in log on { lan wlan } inet proto { tcp udp } \
 to port ntp \
 tagged RELAYD_NTP
pass in log on { enc tun } inet proto { tcp udp } \
 to port ntp keep state (if-bound) \
 tagged RELAYD_NTP

pass in log on { lan wlan } inet6 proto { tcp udp } \
 to port ntp \
 tagged RELAYD6_NTP
pass in log on { enc tun } inet6 proto { tcp udp } \
 to port ntp keep state (if-bound) \
 tagged RELAYD6_NTP

# HTTP Layer 3 redirection
pass in log on { egress lan wlan } inet  proto { tcp udp } \
 to port http \
 tagged RELAYD_WWW
pass in log on { enc tun } inet  proto { tcp udp } \
 to port http keep state (if-bound) \
 tagged RELAYD_WWW

pass in log on { egress lan wlan } inet6 proto { tcp udp } \
 to port http \
 tagged RELAYD6_WWW
pass in log on { enc tun } inet6 proto { tcp udp } \
 to port http keep state (if-bound) \
 tagged RELAYD6_WWW

# HTTPS Acceleration
pass in log on { lan wlan } inet proto { tcp udp } \
 to (athn0) port https
pass in log on { enc tun } inet proto { tcp udp } \
 to (athn0) port https keep state (if-bound)

pass in log on { lan wlan } inet6 proto { tcp udp } \
 to (athn0) port https
pass in log on { enc tun } inet6 proto { tcp udp } \
 to (athn0) port https keep state (if-bound)

pass in log on egress inet  proto { tcp udp } \
 to (egress) port https rdr-to (athn0)
pass in log on egress inet6 proto { tcp udp } \
 to (egress) port https rdr-to fd80:1fe9:fcee:cafe::ace:face # change to athn0?

# Port Knocking Game (nc -z IP PORT)

# 2 knocks on portknock1
#pass in log on egress inet proto tcp \
# from any to (egress:0) port $portknock1 \
# synproxy state (max-src-conn 1, overload <portknock1>) \
# tag INET_SELF

# 3 knocks
#pass in log on egress inet proto tcp \
# from <portknock1> to (egress:0) port $portknock2 \
# synproxy state (max-src-conn 2, overload <portknock2>) \
# tag INET_SELF

# 2 knocks
#pass in log on egress inet proto tcp \
# from <portknock2> to (egress:0) port $portknock3 \
# synproxy state (max-src-conn 1, overload <portknock3>) \
# tag INET_SELF

# Allow successfully port knock'd ips to the sshd daemon
#pass in log on egress inet proto tcp \
# from <portknock3> to (egress:0) port 8080 \
# rdr-to (vether0:0) port ssh \
# keep state (max 6, source-track rule, max-src-nodes 6, max-src-states 6, \
# max-src-conn 6, max-src-conn-rate 6/30, overload <temporaryban> flush global)

# Schedule

# Schedule Table
#table <schedule_ip> persist

# Scheduled access to SSH
#pass in on egress proto tcp from <schedule_ip> to any port ssh keep-state label sched_ip

# System crontab:
#0 18 * * *	root	/sbin/pfctl -k label -k sched_ip
